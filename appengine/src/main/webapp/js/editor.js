/**
 * Contains main algorithm of operations coordination.
 * Also acts as a presenter for view.
 *
 * Main idea of the algorithm is to always be on server track. This can be easily achieved
 * if after sending one operation we will wait for server application of this
 * operation, rebasing all operations generated by the user.
 *
 * So only one operation from each client can be in server queue in one moment. And this operation
 * is based on some revision in the server history.
 */
var initEditor = function (documentId, clientId, view) {

    /**
     * This version is needed to specify the version of document that sent operation
     * was supposed to be applied to.
     */
    var currentDocumentVersion;

    /**
     * Client can't send more than one operation without server acknowledgement of
     * application of the first sent operation.
     */
    var sentOperation = null;

    /**
     * All operations generated by User are waiting in this queue until they'll be able to be sent.
     */
    var pendingOperations = [];

    /**
     * Incoming operations are added to the queue and are processed between User actions.
     */
    var incomingOperationsQueue = [];

    var isMine = function (operation) {
        return operation.initiator === clientId;
    }

    var sendOperation = function (operation) {
        var r = new XMLHttpRequest();
        r.open("POST", "/document/update", true);
        r.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
        var message =
            "op=" + operation.op +
                "&position=" + operation.position +
                "&value=" + operation.value +
                "&documentId=" + documentId +
                "&initiator=" + clientId +
                "&version=" + currentDocumentVersion;
        console.log("Sending operation " + message);
        r.send(message);
        r.onreadystatechange = function () {
            if (r.readyState == 4) {
                if (r.status == 204) {
                    console.log("Operation was sent " + message);
                } else {
                    console.error("Error during sending operation: " + message);
                }
            }
        };
    }

    var trySendPendingOperation = function () {
        if (incomingOperationsQueue.length > 0 || sentOperation !== null) {
            //we can't send operation until we are on the server track
            return;
        }
        if (pendingOperations.length > 0) {
            sentOperation = pendingOperations[0]
            pendingOperations = pendingOperations.slice(1)
            sendOperation(sentOperation);
        } else {
            view.showDocumentIsSaved();
        }
    }

    var applyForeignOperation = function (operation) {
        var operationToApply = operation;
        //transform against sent
        if (sentOperation !== null) {
            var transformed = transformer.transform(operationToApply, sentOperation);
            operationToApply = transformed.first;
            sentOperation = transformed.second;
        }

        //transform against pending
        for (var i = 0; i < pendingOperations.length; i++) {
            var transformed = transformer.transform(operationToApply, pendingOperations[i]);
            operationToApply = transformed.first;
            pendingOperations[i] = transformed.second;
        }
        view.applyOperation(operationToApply);
    }

    /**
     * This function is invoked periodically because incoming operations should
     * be processed between user actions.
     */
    var processIncomingOperation = function () {
        if (!view.isUserActive() && incomingOperationsQueue.length !== 0) {
            var operation = incomingOperationsQueue[0];
            incomingOperationsQueue.splice(0, 1);
            currentDocumentVersion++;
            console.log('Version was incremented ' + currentDocumentVersion)
            if (isMine(operation)) {
                sentOperation = null;
            } else {
                applyForeignOperation(operation);
            }
            trySendPendingOperation();
        }
        setTimeout(processIncomingOperation, 100);
    }
    setTimeout(processIncomingOperation, 100);

    var onIncomingOperation = function (operation) {
        console.log("Operation was received " + JSON.stringify(operation))
        incomingOperationsQueue.push(operation);
    }

    var initEditor = function () {
        console.log("Fetching current document version");
        var request = new XMLHttpRequest();
        request.open("GET", "/document?documentId=" + documentId + "&clientId=" + clientId, true);
        request.onreadystatechange = function () {
            if (request.readyState == 4) {
                if (request.status == 200) {
                    console.log("Document received " + request.responseText);
                    var receivedDocument = JSON.parse(request.responseText);
                    currentDocumentVersion = receivedDocument.documentVersion;
                    view.showDocument(receivedDocument.documentText, receivedDocument.documentTitle);
                } else {
                    console.error("Can't get document: " + request.responseText);
                }
            }
        };
        request.send();
    }

    var initialize = function () {
        initChannel({
                onOpen: initEditor,
                onMessage: onIncomingOperation,
                clientId: clientId
            }
        );
    }

    initialize();

    return {

        /**
         * Supposed to be invoked by the view when user apply some operations.
         */
        onUserOperations: function (operations) {
            if (operations.length > 0) {
                view.showDocumentIsSaving()
                pendingOperations = pendingOperations.concat(operations)
                trySendPendingOperation();
            }
        }
    }
};



